<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teoría de CUBITs - Representación Responsiva</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --accent: #e74c3c;
            --light: #ecf0f1;
            --dark: #2c3e50;
            --success: #2ecc71;
            --warning: #f39c12;
            --purple: #9b59b6;
            --shadow: 0 5px 15px rgba(0,0,0,0.1);
            --transition: all 0.3s ease;
        }

        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
            color: var(--light);
            line-height: 1.6;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            padding: 30px 0;
            margin-bottom: 30px;
            animation: fadeInDown 1s ease;
        }

        h1 {
            font-size: clamp(2rem, 5vw, 3.5rem);
            margin-bottom: 15px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: clamp(1.2rem, 2.5vw, 1.8rem);
            color: var(--warning);
            max-width: 800px;
            margin: 0 auto;
        }
   .card {
            background: rgba(44, 62, 80, 0.85);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: var(--shadow);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            animation: fadeIn 1s ease;
        }

        .card-title {
            color: var(--warning);
            font-size: clamp(1.5rem, 2.5vw, 2rem);
            margin-bottom: 20px;
            position: relative;
            padding-bottom: 10px;
        }

        .card-title::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 60px;
            height: 3px;
            background: var(--secondary);
        }

        .theory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin-top: 30px;
        }

        .theory-card {
            background: rgba(52, 73, 94, 0.7);
            border-radius: 10px;
            padding: 20px;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }

        .theory-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }

        .theory-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background: var(--secondary);
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.5s ease;
        }

        .theory-card:hover::before {
            transform: scaleX(1);
        }

        .theory-card i {
            font-size: 2.5rem;
            margin-bottom: 15px;
            transition: transform 0.3s ease;
        }

        .theory-card:hover i {
            transform: scale(1.2);
        }

        .theory-card h3 {
            color: var(--warning);
            margin-bottom: 10px;
            font-size: 1.4rem;
        }

        .ai-card {
            background: rgba(232, 67, 147, 0.2);
        }

        .ai-card i {
            color: var(--pink);
        }

        .cube-section {
            display: flex;
            flex-wrap: wrap;
            gap: 40px;
            margin-top: 30px;
            justify-content: center;
            align-items: center;
        }

        .cube-container {
            perspective: 1000px;
            width: 200px;
            height: 200px;
            margin: 0 auto;
        }

        .cube {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 1s;
        }

        .face {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 2px solid var(--dark);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            opacity: 0.9;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.3);
        }

        .front { transform: translateZ(100px); background: rgba(231, 76, 60, 0.9); }
        .back { transform: rotateY(180deg) translateZ(100px); background: rgba(52, 152, 219, 0.9); }
        .right { transform: rotateY(90deg) translateZ(100px); background: rgba(46, 204, 113, 0.9); }
        .left { transform: rotateY(-90deg) translateZ(100px); background: rgba(243, 156, 18, 0.9); }
        .top { transform: rotateX(90deg) translateZ(100px); background: rgba(155, 89, 182, 0.9); }
        .bottom { transform: rotateX(-90deg) translateZ(100px); background: rgba(26, 188, 156, 0.9); }

        .controls {
            flex: 1;
            min-width: 300px;
            max-width: 500px;
        }

        .input-group {
            margin-bottom: 25px;
        }

        .input-group h3 {
            color: var(--warning);
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .bit-inputs {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .bit-input {
            width: 100%;
            aspect-ratio: 1/1;
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid var(--secondary);
            border-radius: 8px;
            color: white;
            transition: var(--transition);
        }

        .bit-input:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(231, 76, 60, 0.2);
        }

        .bit-input.active {
            background: var(--success);
            color: var(--dark);
        }

        .ascii-display {
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-family: monospace;
            font-size: 1.1rem;
            text-align: center;
        }

        .cubits-display {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .cubit-column {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
        }

        .cubit-label {
            font-size: 0.8rem;
            color: var(--warning);
            text-align: center;
        }

        .cubit-bit {
            width: 100%;
            aspect-ratio: 1/1;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 5px;
            font-family: monospace;
            font-weight: bold;
            transition: var(--transition);
        }

        .cubit-bit.active {
            background: var(--success);
            color: var(--dark);
            transform: scale(1.1);
        }

        .buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .btn {
            flex: 1;
            min-width: 120px;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-primary {
            background: var(--secondary);
            color: white;
        }

        .btn-secondary {
            background: var(--accent);
            color: white;
        }

        .btn-warning {
            background: var(--warning);
            color: white;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .info-box {
            background: rgba(26, 188, 156, 0.15);
            border-left: 4px solid var(--success);
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        footer {
            text-align: center;
            padding: 30px 0;
            margin-top: 30px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
        }

        /* Animaciones */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

       
        @media (max-width: 768px) {
            .cube-section {
                flex-direction: column;
                gap: 30px;
            }
            
            .bit-inputs {
                grid-template-columns: repeat(4, 1fr);
            }
            
            .cubits-display {
                grid-template-columns: repeat(4, 1fr);
            }
            
            .buttons {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
            }
        }

        @media (max-width: 480px) {
            .bit-inputs {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .cubits-display {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .cube-container {
                width: 150px;
                height: 150px;
            }
            
            .face {
                font-size: 1.2rem;
            }
        }
      
        .formula-container {
            background: rgba(52, 152, 219, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .math-formula {
            font-size: 1.8rem;
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            font-family: "Courier New", monospace;
            color: #f39c12;
            border-left: 3px solid #3498db;
        }

        .math-var {
            font-family: "Times New Roman", serif;
            font-style: italic;
            color: #2ecc71;
        }

        .math-op {
            color: #e74c3c;
            font-weight: bold;
        }

        .cubit-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            background: rgba(0, 0, 0, 0.1);
        }

        .cubit-table th, .cubit-table td {
            padding: 12px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .cubit-table th {
            background-color: rgba(52, 152, 219, 0.3);
            color: #ecf0f1;
        }

        .cubit-table tr:nth-child(even) {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .cubit-table tr:hover {
            background-color: rgba(46, 204, 113, 0.1);
        }

        .example {
            margin-top: 30px;
            padding-top: 15px;
            border-top: 1px dashed rgba(255, 255, 255, 0.2);
        }

        @media (max-width: 768px) {
            .math-formula {
                font-size: 1.4rem;
            }
            
            .cubit-table {
                font-size: 0.9rem;
            }
        }
      
      
        .row-bytes-section {
            background: rgba(155, 89, 182, 0.2);
            border-radius: 15px;
            padding: 20px;
            margin-top: 30px;
            border-left: 4px solid #9b59b6; 
        }

        .row-bytes-display {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }

        .row-byte {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .row-label {
            min-width: 80px;
            font-weight: bold;
            color: #f39c12; 
        }

        .row-bits {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 8px;
            flex: 1;
        }

        .row-bit {
            width: 100%;
            aspect-ratio: 1/1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            font-family: monospace;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .row-bit.active {
            background: #9b59b6; 
            color: white;
            transform: scale(1.1);
        }

        .row-ascii {
            min-width: 120px;
            font-family: monospace;
            font-weight: bold;
            color: #2ecc71; 
        }

        @media (max-width: 768px) {
            .row-byte {
                flex-direction: column;
                align-items: flex-start;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Teoría de CUBITs</h1>
            <p class="subtitle">Es un modelo conceptual que propone una nueva forma de interpretar y leer los bits digitales, basando su comprensión en estructuras multidimensionales, donde cada bit adquiere propiedades espaciales y contextuales que permiten representar relaciones, transformaciones y patrones más complejos que en el modelo binario lineal tradicional.</p>
            <div class="separator" style="clear: both;">
                <a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgyyQivqDmYKNeEISCsYopDLBwb5RPMY40N0jCYHXb64EhWCfn40y4nIAEanK0EpoC7qEtMjLVnRei9M9rmUaaFQICvi2yN2apa5GoTgSO9hwtTwpjutSBPBRciR9sVCYmTjEtlQhlF3glJP2G9vH3f9vElNDI89x9e4ro-W0FRi5_tjpjHA6U-Ifx9fKU/s1024/IMG_20250718_114302.jpg" 
                   style="display: block; padding: 1em 0; text-align: center;">
                    <img 
                      alt="" 
                      border="0" 
                      width="400" 
                      style="border-radius: 20px;" 
                      data-original-height="1024" 
                      data-original-width="1024" 
                      src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgyyQivqDmYKNeEISCsYopDLBwb5RPMY40N0jCYHXb64EhWCfn40y4nIAEanK0EpoC7qEtMjLVnRei9M9rmUaaFQICvi2yN2apa5GoTgSO9hwtTwpjutSBPBRciR9sVCYmTjEtlQhlF3glJP2G9vH3f9vElNDI89x9e4ro-W0FRi5_tjpjHA6U-Ifx9fKU/s400/IMG_20250718_114302.jpg"/>
                </a>
            </div>
        </header>

        <main>
            <div class="card">
   <p class="subtitle">1 Byte Multi-Dimensional</p>
   <p class="subtitle">1 Bit en 6 Dimensiones</p>
                <h2 class="card-title">¿Qué es la Teoría de CUBITs?</h2>
                <p>La Teoría de CUBITs es un modelo conceptual innovador que propone una nueva forma de representar y procesar información digital utilizando estructuras en múltiples dimensiones. El término "CUBIT" fusiona "CUBE" (cubo) y "BIT" (unidad mínima de información), representando una unidad de datos con propiedades espaciales.</p><br>
              
                <p>Propuesta por <strong>Arnaldo A. Ozorio</strong> enfoca una nueva manera de representar y procesar información digital utilizando estructuras multidimensionales.</p><br>
                <p>Este concepto dice que 1 Byte consta de 8 Bits, y estos pueden formar un Cubo 3D usando los Bits adyacentes, asi por cada Bit se forma un Cubo de 6 lados. De esta forma por cada Cara de los 8 cubos Bit o CUBIT concatenados tenemos como resultante</p>
              <p>[6 Bytes o 48 Bits] = 1 Byte CUBITs</p><br>
       <small>       
             <li style="small";> 1 byte= Cara1[B1]; Cara1[B2]; Cara1[B3]; Cara1[B4]; Cara1[B5]; Cara1[B6]; Cara1[B7]; Cara1[B8] = 8 Bits</li>
             <li style="small";> 2 byte= Cara2[B1]; Cara2[B2]; Cara2[B3]; Cara2[B4]; Cara2[B5]; Cara2[B6]; Cara2[B7]; Cara2[B8] = 8 Bits</li>
              <li style="small";>3 byte= Cara3[B1];..</li> 
               <li> ..</li>
         <li>6 byte= Cara6[B1]; Cara6[B2]; Cara6[B3]; Cara6[B4]; Cara6[B5]; Cara6[B6]; Cara6[B7]; Cara6[B8] = 8 Bits</li>
         </small><br>
              
                <p>Entonces en lugar de que 1 Byte normal contenga 8 Bits de información, ahora gracias a los CUBITs tendria 48 Bits conceptualmente.</p>
                
                <div class="info-box">
                    <p><strong>Naturaleza conceptual:</strong> Esta teoría es un ejercicio especulativo que, aunque no corresponde a sistemas reales actuales, ofrece nuevas perspectivas para:</p>
                    <ul>
                        <li>Visualización alternativa de datos binarios</li>
                        <li>Exploración de representaciones tridimensionales</li>
                        <li>Desarrollo de modelos educativos interactivos</li>
                        <li>Inspiración para interfaces innovadoras</li>
                      <li>Redes neuronales para Inteligencia Artificial</li>
                 <li>Computación Cuántica</li>     
                    </ul>
                </div>
            </div>

                      
         <div class="card">
    <h2 class="card-title">Fórmula Matemática de Conversión Byte Multidimensional</h2>
    
    <div class="formula-container">
        <h3>De Byte (8 bits) a CUBITs (8 × 6 bits)</h3>
        
        <div class="formula">
            <p>Para un byte <span class="math-var">B = b<sub>7</sub>b<sub>6</sub>b<sub>5</sub>b<sub>4</sub>b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub></span></p>
            
            <p>El CUBIT <span class="math-var">C<sub>k</sub></span> (para <span class="math-var">k = 0</span> a <span class="math-var">7</span>) se calcula como:</p>
            
            <div class="math-formula">
                C<sub>k</sub> = <span class="math-op">⊕</span><sub>i=0</sub><sup>5</sup> b<sub>(k+i) mod 8</sub>
            </div>
            
            <p>Donde:</p>
            <ul>
                <li><span class="math-op">⊕</span> = concatenación de bits</li>
                <li><span class="math-var">mod 8</span> = desplazamiento circular</li>
            </ul>
        </div>
        
        <div class="example">
            <h4>Ejemplo para B = 11001010:</h4>
            <table class="cubit-table">
                <tr>
                    <th>CUBIT (C<sub>k</sub>)</th>
                    <th>Bits seleccionados</th>
                    <th>Resultado 1 BYTE CUBITs
                      6Columnas x 8filas</th>
                </tr>
                <tr>
                    <td>C<sub>0</sub></td>
                    <td>b<sub>0</sub>b<sub>1</sub>b<sub>2</sub>b<sub>3</sub>b<sub>4</sub>b<sub>5</sub></td>
                    <td>0 | 1 | 0 | 1 | 0 | 0</td>
                </tr>
                <tr>
                    <td>C<sub>1</sub></td>
                    <td>b<sub>1</sub>b<sub>2</sub>b<sub>3</sub>b<sub>4</sub>b<sub>5</sub>b<sub>6</sub></td>
                    <td>1 | 0 |1 | 0 | 0 | 1</td>
                </tr>
                <tr>
                    <td>C<sub>2</sub></td>
                    <td>b<sub>2</sub>b<sub>3</sub>b<sub>4</sub>b<sub>5</sub>b<sub>6</sub>b<sub>7</sub></td>
                    <td>0 | 1 | 0 | 0 | 1 | 1</td>
                </tr>
                <tr>
                    <td>C<sub>3</sub></td>
                    <td>b<sub>3</sub>b<sub>4</sub>b<sub>5</sub>b<sub>6</sub>b<sub>7</sub>b<sub>0</sub></td>
                    <td>1 | 0 | 0 | 1 | 1 | 0</td>
                </tr>
                <tr>
                    <td>C<sub>4</sub></td>
                    <td>b<sub>4</sub>b<sub>5</sub>b<sub>6</sub>b<sub>7</sub>b<sub>0</sub>b<sub>1</sub></td>
                    <td>0 | 0 | 1 | 1 | 0 | 1</td>
                </tr>
                <tr>
                    <td>C<sub>5</sub></td>
                    <td>b<sub>5</sub>b<sub>6</sub>b<sub>7</sub>b<sub>0</sub>b<sub>1</sub>b<sub>2</sub></td>
                    <td>0 | 1 | 1 | 0 | 1 | 0</td>
                </tr>
                <tr>
                    <td>C<sub>6</sub></td>
                    <td>b<sub>6</sub>b<sub>7</sub>b<sub>0</sub>b<sub>1</sub>b<sub>2</sub>b<sub>3</sub></td>
                    <td>1 | 1 | 0 | 1 | 0 | 1</td>
                </tr>
                <tr>
                    <td>C<sub>7</sub></td>
                    <td>b<sub>7</sub>b<sub>0</sub>b<sub>1</sub>b<sub>2</sub>b<sub>3</sub>b<sub>4</sub></td>
                    <td>1 | 0 | 1 | 0 | 1 | 0</td>
                </tr>
            </table>
        </div>
    </div>
</div>

            
            <div class="card">
  <h2 class="card-title">Demostración Interactiva</h2>
  <div class="cube-section" style="display: flex; gap: 15px;">
    
    <div class="cube-container">
      <div class="cube">
        <div class="face front">F</div>
        <div class="face back">B</div>
        <div class="face right">R</div>
        <div class="face left">L</div>
        <div class="face top">T</div>
        <div class="face bottom">M</div>
      </div>
    </div>

    <div class="cube-section" style="display: flex; gap: 15px;">
    <div class="cube-container">
      <div class="cube">
        <div class="face front">F</div>
        <div class="face back">B</div>
        <div class="face right">R</div>
        <div class="face left">L</div>
        <div class="face top">T</div>
        <div class="face bottom">M</div>
      </div>
    </div>

    <div class="cube-container">
      <div class="cube">
        <div class="face front">F</div>
        <div class="face back">B</div>
        <div class="face right">R</div>
        <div class="face left">L</div>
        <div class="face top">T</div>
        <div class="face bottom">M</div>
      </div>
    </div>

    <div class="cube-container">
      <div class="cube">
        <div class="face front">F</div>
        <div class="face back">B</div>
        <div class="face right">R</div>
        <div class="face left">L</div>
        <div class="face top">T</div>
        <div class="face bottom">M</div>
      </div>
    </div>

    <div class="cube-container">
      <div class="cube">
        <div class="face front">F</div>
        <div class="face back">B</div>
        <div class="face right">R</div>
        <div class="face left">L</div>
        <div class="face top">T</div>
        <div class="face bottom">M</div>
      </div>
    </div>

    <div class="cube-container">
      <div class="cube">
        <div class="face front">F</div>
        <div class="face back">B</div>
        <div class="face right">R</div>
        <div class="face left">L</div>
        <div class="face top">T</div>
        <div class="face bottom">M</div>
      </div>
    </div>

    <div class="cube-container">
      <div class="cube">
        <div class="face front">F</div>
        <div class="face back">B</div>
        <div class="face right">R</div>
        <div class="face left">L</div>
        <div class="face top">T</div>
        <div class="face bottom">M</div>
      </div>
    </div>

    <div class="cube-container">
      <div class="cube">
        <div class="face front">F</div>
        <div class="face back">B</div>
        <div class="face right">R</div>
        <div class="face left">L</div>
        <div class="face top">T</div>
        <div class="face bottom">M</div>
      </div>
    </div>
  </div>
</div>

          
          
                   <div class="buttons">
                            <button class="btn btn-primary" id="randomizeBtn">
                                <i class="fas fa-dice"></i> Aleatorio
                            </button>
                            <button class="btn btn-secondary" id="resetBtn">
                                <i class="fas fa-redo"></i> Reiniciar
                            </button>
                            <button class="btn btn-warning" id="rotateBtn">
                                <i class="fas fa-sync"></i> Rotar
                            </button>
                        </div>
                    
                    <div class="controls">
                        <div class="input-group">
                            <h3>Byte Raiz o Byte de Entrada (8 bits)</h3>
                            <div class="bit-inputs" id="byteInput">
                          
                            </div>
                            <div class="ascii-display">
                                Valor ASCII: <span id="asciiByte">N/A</span>
                            </div>
                        </div>
                        
                        <div class="input-group">
                            <h3>Representación CUBIT (6 bits cada uno)</h3>
                            <div class="cubits-display" id="cubitsDisplay">
                              
                            </div>
                            <div class="ascii-display">
                                Valores ASCII CUBITs: <span id="asciiCubits"></span>
                            </div>
                        </div>
                    </div>
                </div>
                
               
              <div class="row-bytes-section">
                    <h3 class="card-title">1 Byte CUBITs (6 bytes de 8 bits) - UTF-8</h3>
                    <p>Concatenando cada fila de las 8 columnas CUBITs forma un Byte completo que puede representar un carácter UTF-8.</p>
                    <div class="utf8-display">
                        <small><strong>Nota:</strong> Los caracteres UTF-8 pueden incluir emojis, símbolos y caracteres especiales.</small>
                    </div>
                    <div class="row-bytes-display" id="rowBytesDisplay">
                        
                    </div>
                </div>
            </div>
        </main>      <div class="card">
                <h2 class="card-title">Aplicaciones Conceptuales</h2>
                <div class="theory-grid">
                    <div class="theory-card">
                        <i class="fas fa-graduation-cap"></i>
                        <h3>Educación Digital</h3>
                        <p>Enseñar conceptos binarios y UTF-8 mediante representaciones 3D interactivas que facilitan la comprensión visual.</p>
                    </div>
                    <div class="theory-card">
                        <i class="fas fa-language"></i>
                        <h3>Internacionalización</h3>
                        <p>Visualizar cómo los diferentes sistemas de codificación representan caracteres de múltiples idiomas.</p>
                    </div>
                    <div class="theory-card">
                        <i class="fas fa-gamepad"></i>
                        <h3>Mecánicas de Juego</h3>
                        <p>Diseñar puzzles y desafíos donde los datos se manipulan mediante rotaciones espaciales.</p>
                    </div>
                    <div class="theory-card">
                        <i class="fas fa-brain"></i>
                        <h3>Pensamiento Computacional</h3>
                        <p>Fomentar nuevas formas de conceptualizar problemas mediante metáforas espaciales.</p>
                    </div>
                  
          
                  
      <div class="theory-card crypto-card">
                    <i class="fas fa-lock"></i>
                    <h3>Criptografía</h3>
                    <p>Encriptación de mensajes a nivel de bit mediante transformaciones espaciales de CUBITs.</p>
                    <div class="feature-list">
                        <p><i class="fas fa-key"></i> Algoritmos de cifrado basados en rotaciones 3D</p>
                        <p><i class="fas fa-shield-alt"></i> Seguridad mejorada con capas de transformación</p>
                        <p><i class="fas fa-sync-alt"></i> Reconfiguración dinámica de claves</p>
                    </div>
                </div>
                
             
                <div class="theory-card quantum-card">
                    <i class="fas fa-atom"></i>
                    <h3>Procesadores Cuasi-Cuánticos</h3>
                    <p>Procesamiento paralelo con paquetes de bytes representados como CuBits.</p>
                    <div class="feature-list">
                        <p><i class="fas fa-microchip"></i> Procesamiento simultáneo de múltiples estados</p>
                        <p><i class="fas fa-bolt"></i> Velocidad exponencial en operaciones específicas</p>
                        <p><i class="fas fa-infinity"></i> Modelado de superposición de estados</p>
                    </div>
                </div>
           
                <div class="theory-card signature-card">
                    <i class="fas fa-signature"></i>
                    <h3>Firmas Digitales</h3>
                    <p>Generación de firmas únicas a nivel de bit mediante estructuras CUBIT.</p>
                    <div class="feature-list">
                        <p><i class="fas fa-fingerprint"></i> Identificación única basada en geometría de bits</p>
                        <p><i class="fas fa-qrcode"></i> Generación de huellas digitales irrepeticables</p>
                        <p><i class="fas fa-shield-alt"></i> Verificación de integridad mediante rotaciones</p>
                    </div>
                </div>
                
           
                <div class="theory-card ai-card">
                    <i class="fas fa-microchip"></i>
                    <h3>IA y Procesamiento Neuronal</h3>
                    <p>Modelar redes neuronales con estructuras CUBIT para procesamiento paralelo.</p>
                    <div class="feature-list">
                        <p><i class="fas fa-brain"></i> Representación 3D de conexiones neuronales</p>
                        <p><i class="fas fa-project-diagram"></i> Arquitecturas paralelas para aprendizaje profundo</p>
                        <p><i class="fas fa-lightbulb"></i> Optimización de procesos cognitivos</p>
                    </div>
                </div>
            </div>
  
      
        
        <footer>
            <p>Teoría de CUBITs - Un modelo conceptual para la representación tridimensional de datos</p>
            <p>En desarrollo experimental - Arnaldo A. Ozorio</p>
        </footer>
    </div>
  
<script>        
   
    const cubes = document.querySelectorAll('.cube');
    const byteInputContainer = document.getElementById('byteInput');
    const cubitsDisplayContainer = document.getElementById('cubitsDisplay');
    const rowBytesDisplayContainer = document.getElementById('rowBytesDisplay');
    const asciiByteSpan = document.getElementById('asciiByte');
    const asciiCubitsSpan = document.getElementById('asciiCubits');
    const randomizeBtn = document.getElementById('randomizeBtn');
    const resetBtn = document.getElementById('resetBtn');
    const rotateBtn = document.getElementById('rotateBtn');
    
    // Crear inputs para el byte
    for (let i = 0; i < 8; i++) {
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'bit-input';
        input.maxLength = 1;
        input.dataset.index = i;
        input.value = '0';
        input.addEventListener('input', handleBitInput);
        byteInputContainer.appendChild(input);
    }
    
    // Crear representación CUBIT
    for (let i = 0; i < 8; i++) {
        const column = document.createElement('div');
        column.className = 'cubit-column';
        column.dataset.index = i;
        
        const label = document.createElement('div');
        label.className = 'cubit-label';
        label.textContent = `CUBIT ${i+1}`;
        column.appendChild(label);
        
        for (let j = 0; j < 6; j++) {
            const bit = document.createElement('div');
            bit.className = 'cubit-bit';
            bit.dataset.bitIndex = j;
            bit.textContent = '0';
            column.appendChild(bit);
        }
        cubitsDisplayContainer.appendChild(column);
    }
    
    // Crear filas de bytes
    for (let i = 0; i < 6; i++) {
        const rowByte = document.createElement('div');
        rowByte.className = 'row-byte';
        rowByte.dataset.row = i;
        
        const label = document.createElement('div');
        label.className = 'row-label';
        label.textContent = `BYTE ${i+1}:`;
        rowByte.appendChild(label);
        
        const bitsContainer = document.createElement('div');
        bitsContainer.className = 'row-bits';
        
        for (let j = 0; j < 8; j++) {
            const bit = document.createElement('div');
            bit.className = 'row-bit';
            bit.dataset.bitIndex = j;
            bit.textContent = '0';
            bitsContainer.appendChild(bit);
        }
        rowByte.appendChild(bitsContainer);
        
        const utf8 = document.createElement('div');
        utf8.className = 'row-utf8';
        utf8.textContent = '→ 0 (NUL)';
        utf8.id = `rowUtf8${i}`;
        rowByte.appendChild(utf8);
        
        rowBytesDisplayContainer.appendChild(rowByte);
    }
    
    // Función para rotar todos los cubos simultáneamente
    rotateBtn.addEventListener('click', () => {
        cubes.forEach(cube => {
            const currentRotation = cube.style.transform || 'rotateX(0) rotateY(0)';
            const values = currentRotation.match(/\d+/g) || [0, 0];
            const xRot = (parseInt(values[0] || 0) + 90) % 360;
            const yRot = (parseInt(values[1] || 0) + 90) % 360;
            cube.style.transform = `rotateX(${xRot}deg) rotateY(${yRot}deg)`;
            cube.style.transition = 'transform 1s ease';
        });
    });
    
    // Función para rotar cubos aleatoriamente
    function rotateCubeRandomly() {
        cubes.forEach(cube => {
            const xRot = Math.floor(Math.random() * 360);
            const yRot = Math.floor(Math.random() * 360);
            cube.style.transform = `rotateX(${xRot}deg) rotateY(${yRot}deg)`;
        });
    }
    
    // Función para manejar inputs de bits
    function handleBitInput(e) {
        const value = e.target.value;
        if (value !== '0' && value !== '1') {
            e.target.value = '';
            return;
        }
        e.target.classList.toggle('active', value === '1');
        updateCubitsDisplay();
        updateAsciiValues();
        updateRowBytesDisplay();
    }
    
    // Función para actualizar la representación CUBIT
    function updateCubitsDisplay() {
        const inputs = document.querySelectorAll('.bit-input');
        const byte = Array.from(inputs).map(input => input.value).join('');
        
        for (let i = 0; i < 8; i++) {
            const cubitBits = [];
            for (let j = 0; j < 6; j++) {
                const bitIndex = (i + j) % 8;
                cubitBits.push(byte[bitIndex]);
            }
            const column = document.querySelector(`.cubit-column[data-index="${i}"]`);
            const bits = column.querySelectorAll('.cubit-bit');
            cubitBits.forEach((bit, index) => {
                bits[index].textContent = bit;
                bits[index].classList.toggle('active', bit === '1');
            });
        }
    }
    
    // Función para actualizar valores ASCII
    function updateAsciiValues() {
        const inputs = document.querySelectorAll('.bit-input');
        const byte = Array.from(inputs).map(input => input.value).join('');
        
        const byteValue = parseInt(byte, 2);
        asciiByteSpan.textContent = byteValue >= 32 && byteValue <= 126 ? 
            `${byteValue} → '${String.fromCharCode(byteValue)}'` : 
            `${byteValue} → (No imprimible)`;
        
        const cubitAscii = [];
        for (let i = 0; i < 8; i++) {
            const cubitBits = [];
            for (let j = 0; j < 6; j++) {
                const bitIndex = (i + j) % 8;
                cubitBits.push(byte[bitIndex]);
            }
            const cubitValue = parseInt(cubitBits.join(''), 2);
            cubitAscii.push(cubitValue >= 32 && cubitValue <= 126 ? 
                `'${String.fromCharCode(cubitValue)}'` : 
                'X');
        }
        asciiCubitsSpan.textContent = cubitAscii.join(' ');
    }
    
    // Función para actualizar filas de bytes
    function updateRowBytesDisplay() {
        const inputs = document.querySelectorAll('.bit-input');
        const byte = Array.from(inputs).map(input => input.value).join('');
        
        for (let row = 0; row < 6; row++) {
            const rowBits = [];
            for (let col = 0; col < 8; col++) {
                const bitIndex = (col + row) % 8;
                rowBits.push(byte[bitIndex]);
            }
            const rowByte = rowBits.join('');
            const rowValue = parseInt(rowByte, 2);
            
            const rowElement = document.querySelector(`.row-byte[data-row="${row}"]`);
            const bits = rowElement.querySelectorAll('.row-bit');
            rowBits.forEach((bit, index) => {
                bits[index].textContent = bit;
                bits[index].classList.toggle('active', bit === '1');
            });
            
            const utf8Element = rowElement.querySelector('.row-utf8');
            let char = '';
            let displayText = '';
            
            if (rowValue === 0) {
                displayText = `→ ${rowValue} (NUL)`;
            } else if (rowValue < 32 || rowValue === 127) {
                displayText = `→ ${rowValue} (Control)`;
            } else if (rowValue >= 128 && rowValue <= 255) {
                char = String.fromCodePoint(rowValue);
                displayText = `→ ${rowValue} ${char} (UTF-8)`;
            } else {
                char = String.fromCharCode(rowValue);
                displayText = `→ ${rowValue} '${char}'`;
            }
            
            utf8Element.textContent = displayText;
        }
    }
    
    // Evento para el botón Aleatorio
    randomizeBtn.addEventListener('click', () => {
        const inputs = document.querySelectorAll('.bit-input');
        inputs.forEach(input => {
            const value = Math.random() > 0.5 ? '1' : '0';
            input.value = value;
            input.classList.toggle('active', value === '1');
        });
        
        // Rotar cubos aleatoriamente
        rotateCubeRandomly();
        
        updateCubitsDisplay();
        updateAsciiValues();
        updateRowBytesDisplay();
    });
    
    // Evento para el botón Reiniciar
    resetBtn.addEventListener('click', () => {
        const inputs = document.querySelectorAll('.bit-input');
        inputs.forEach(input => {
            input.value = '0';
            input.classList.remove('active');
        });
        
        // Reiniciar rotación de cubos
        cubes.forEach(cube => {
            cube.style.transform = 'rotateX(0) rotateY(0)';
        });
        
        updateCubitsDisplay();
        updateAsciiValues();
        updateRowBytesDisplay();
    });
    
    // Inicializar display
    updateCubitsDisplay();
    updateAsciiValues();
    updateRowBytesDisplay();
</script>
</body>
  
  <footer>
    <p>Copyright © 2025 | CUBITs | <a href="https://informaticabigbosspy.blogspot.com/p/principal.html"><strong>BIG BOSS Informática || Servicios</strong></a>.<br>
      Todos los derechos reservados.</p>
  </footer>
</html>


