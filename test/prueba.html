<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador CUBITs - Matrices 8x8</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --accent: #e74c3c;
            --light: #ecf0f1;
            --dark: #2c3e50;
            --success: #2ecc71;
            --warning: #f39c12;
            --purple: #9b59b6;
            --crypto: #f1c40f;
            --shadow: 0 5px 15px rgba(0,0,0,0.1);
            --transition: all 0.3s ease;
        }

        body {
            background: linear-gradient(135deg, #1a2a6c, #2c3e50, #1a2a6c);
            color: var(--light);
            line-height: 1.6;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            padding: 30px 0;
            margin-bottom: 20px;
        }

        h1 {
            font-size: clamp(2rem, 5vw, 3.5rem);
            margin-bottom: 15px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            color: var(--warning);
        }

        .subtitle {
            font-size: clamp(1.1rem, 2.5vw, 1.5rem);
            color: var(--secondary);
            max-width: 800px;
            margin: 0 auto 30px;
        }

        .card {
            background: rgba(44, 62, 80, 0.9);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: var(--shadow);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .card-title {
            color: var(--warning);
            font-size: clamp(1.3rem, 2.5vw, 1.8rem);
            margin-bottom: 20px;
            position: relative;
            padding-bottom: 10px;
        }

        .card-title::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 60px;
            height: 3px;
            background: var(--secondary);
        }

        .converter-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 20px;
        }

        .input-group {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        .char-input-container {
            width: 100%;
            max-width: 300px;
        }

        .char-input-label {
            display: block;
            margin-bottom: 8px;
            color: var(--warning);
            font-weight: bold;
            text-align: center;
        }

        .char-input {
            width: 100%;
            padding: 15px;
            border: 2px solid var(--secondary);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1.2rem;
            text-align: center;
        }

        .char-input:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(231, 76, 60, 0.2);
        }

        .btn-convert {
            padding: 15px 30px;
            background: var(--secondary);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 10px auto;
        }

        .btn-convert:hover {
            background: #2980b9;
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .output-section {
            margin-top: 30px;
        }

        .matrix-container {
            margin-bottom: 40px;
        }

        .matrix-title {
            color: var(--warning);
            font-size: 1.5rem;
            margin-bottom: 15px;
            text-align: center;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }

        .cubit-matrix {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 5px;
            margin-top: 20px;
        }

        .matrix-header {
            background: rgba(52, 152, 219, 0.3);
            padding: 10px;
            text-align: center;
            font-weight: bold;
            border-radius: 5px;
        }

        .matrix-cell {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            text-align: center;
            border-radius: 5px;
            font-family: monospace;
            min-width: 30px;
        }

        .matrix-cell.active {
            background: var(--success);
            color: var(--dark);
            font-weight: bold;
        }

        .info-panel {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }

        .info-title {
            color: var(--warning);
            margin-bottom: 10px;
        }

        .row-column-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 15px;
        }

        .row-info, .column-info {
            background: rgba(0,0,0,0.1);
            padding: 15px;
            border-radius: 8px;
        }

        .row-item, .column-item {
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 5px;
            font-family: monospace;
        }

        .char-result {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 30px;
            justify-content: center;
        }

        .char-result-box {
            flex: 0 0 calc(33% - 20px);
            min-width: 200px;
            background: rgba(243, 156, 18, 0.2);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
        }

        .result-title {
            color: var(--warning);
            font-size: 1.2rem;
            margin-bottom: 15px;
        }

        .result-byte {
            font-family: monospace;
            font-size: 1.1rem;
            margin: 10px 0;
            word-break: break-all;
        }

        .result-char {
            font-size: 3rem;
            margin: 15px 0;
            min-height: 60px;
        }

        .result-value {
            font-size: 1.1rem;
            color: #ccc;
        }

        .analysis-section {
            background: rgba(26, 188, 156, 0.1);
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
            border-left: 4px solid var(--success);
        }

        .bit-visualization {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 8px;
            margin: 20px 0;
        }

        .bit-cell {
            aspect-ratio: 1/1;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: monospace;
            font-weight: bold;
            transition: var(--transition);
        }

        .bit-cell.active {
            background: var(--crypto);
            color: var(--dark);
            transform: scale(1.1);
        }

        .crypto-analysis {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .crypto-card {
            background: rgba(44, 62, 80, 0.7);
            border-radius: 10px;
            padding: 20px;
            border-top: 3px solid var(--crypto);
        }

        .crypto-title {
            color: var(--crypto);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .key-generation {
            background: rgba(155, 89, 182, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-top: 30px;
        }

        .key-display {
            font-family: monospace;
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            word-break: break-all;
            font-size: 1.1rem;
        }

        .visualization-3d {
            height: 400px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 15px;
            margin-top: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .visualization-placeholder {
            color: rgba(255, 255, 255, 0.3);
            font-size: 1.2rem;
        }

        @media (max-width: 768px) {
            .cubit-matrix {
                grid-template-columns: repeat(5, 1fr);
            }
            
            .matrix-cell {
                padding: 8px;
                font-size: 0.9rem;
            }
            
            .bit-visualization {
                grid-template-columns: repeat(8, 1fr);
            }
            
            .crypto-analysis {
                grid-template-columns: 1fr;
            }
            
            .char-result-box {
                flex: 0 0 calc(50% - 20px);
            }
            
            .row-column-info {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 480px) {
            .bit-visualization {
                grid-template-columns: repeat(6, 1fr);
            }
            
            .char-result-box {
                flex: 0 0 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Simulador CUBITs - Matrices 8x8</h1>
            <p class="subtitle">Desplazamiento a derecha e izquierda con análisis completo en filas y columnas</p>
        </header>

        <main>
            <div class="card">
                <h2 class="card-title">Conversor de Caracteres a Matrices 8x8</h2>
                <div class="converter-container">
                    <div class="input-group">
                        <div class="char-input-container">
                            <label class="char-input-label">Ingresa un carácter:</label>
                            <input type="text" class="char-input" id="charInput" maxlength="1" value="A">
                        </div>
                    </div>
                    
                    <button class="btn-convert" id="convertBtn">
                        <i class="fas fa-sync-alt"></i> Generar Matrices
                    </button>
                </div>
            </div>
            
            <div class="card">
                <h2 class="card-title">Matrices CUBITs 8x8</h2>
                <div id="outputSection" class="output-section">
                    <p>Ingresa un carácter y haz clic en "Generar Matrices" para ver las representaciones</p>
                </div>
            </div>
            
            <div class="analysis-section">
                <h2 class="card-title">Análisis de los 128 Bits Generados</h2>
                
                <h3>Visualización de los 128 bits (64 por matriz):</h3>
                <div class="bit-visualization" id="bitVisualization">
                    <!-- Los bits se generarán aquí -->
                </div>
                
                <div class="key-generation">
                    <h3>Generación de Clave Criptográfica (128 bits):</h3>
                    <div class="key-display" id="cryptoKey">00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</div>
                    <p>Hex: <span id="hexKey">0x0</span> | Base64: <span id="base64Key">MA==</span></p>
                </div>
                
                <h3>Análisis Comparativo con Algoritmos Históricos:</h3>
                <div class="crypto-analysis">
                    <div class="crypto-card">
                        <h4 class="crypto-title"><i class="fas fa-lock"></i> Cifrado César</h4>
                        <p>El cifrado César desplaza cada letra un número fijo de posiciones. Con 128 bits podemos generar un desplazamiento dinámico.</p>
                        <div class="key-display">Desplazamiento: <span id="caesarShift">3</span></div>
                    </div>
                    
                    <div class="crypto-card">
                        <h4 class="crypto-title"><i class="fas fa-key"></i> Enigma</h4>
                        <p>La máquina Enigma usaba rotores para cifrado. Podemos simular rotores con patrones de bits.</p>
                        <div class="key-display">Patrón de rotor: <span id="enigmaPattern">101001</span></div>
                    </div>
                    
                    <div class="crypto-card">
                        <h4 class="crypto-title"><i class="fas fa-code"></i> AES-256</h4>
                        <p>AES es el estándar actual de cifrado. Los 128 bits pueden expandirse a una clave de 256 bits mediante funciones de derivación.</p>
                        <div class="key-display">Clave derivada: <span id="aesKey">a3f8...d92c</span></div>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <h2 class="card-title">Teoría de Matrices 8x8 en CUBITs</h2>
                <p>La estructura CUBITs extendida a matrices 8x8 permite un aprovechamiento superior de la información:</p>
                
                <div class="info-box" style="background: rgba(241, 196, 15, 0.1); border-left: 4px solid var(--crypto); padding: 15px; border-radius: 0 8px 8px 0;">
                    <h3 style="color: var(--crypto);">Principios de explotación criptográfica:</h3>
                    <ul style="margin: 15px 0; padding-left: 20px;">
                        <li><strong>Densidad informativa:</strong> 1 byte tradicional → 128 bits efectivos (1600% más información)</li>
                        <li><strong>Complejidad exponencial:</strong> 2¹²⁸ combinaciones (3.4×10³⁸) vs 2⁸ (256) tradicional</li>
                        <li><strong>Bidireccionalidad:</strong> Dos matrices complementarias (derecha/izquierda) para mayor robustez</li>
                        <li><strong>Multidimensionalidad:</strong> Relaciones espaciales entre bits añaden capas adicionales de significado</li>
                    </ul>
                </div>
            </div>
        </main>
        
        <footer style="text-align: center; padding: 30px 0; margin-top: 30px; border-top: 1px solid rgba(255,255,255,0.1);">
            <p>Teoría de CUBITs - Matrices 8x8 - Análisis Criptográfico Avanzado</p>
            <p>Desarrollado por Arnaldo A. Ozorio | 2025</p>
        </footer>
    </div>

    <script>
        document.getElementById('convertBtn').addEventListener('click', convertToCubits);
        
        function convertToCubits() {
            const outputSection = document.getElementById('outputSection');
            outputSection.innerHTML = '';
            
            const charInput = document.getElementById('charInput');
            const char = charInput.value;
            
            if (char) {
                const charCode = char.charCodeAt(0);
                const binaryByte = charCode.toString(2).padStart(8, '0');
                
                // Generar ambas matrices 8x8
                const matrixRight = generateRightShiftMatrix(binaryByte);
                const matrixLeft = generateLeftShiftMatrix(binaryByte);
                
                // Mostrar ambas matrices
                outputSection.appendChild(createMatrixSection('Matriz 8x8 - Desplazamiento Derecha', matrixRight, binaryByte));
                outputSection.appendChild(createMatrixSection('Matriz 8x8 - Desplazamiento Izquierda', matrixLeft, binaryByte));
                
                // Realizar análisis avanzado con todos los bits
                performAdvancedAnalysis(matrixRight, matrixLeft);
            } else {
                outputSection.innerHTML = '<p>Por favor ingresa un carácter</p>';
            }
        }
        
        function generateRightShiftMatrix(byte) {
            const matrix = [];
            
            // Crear matriz 8x8 con desplazamiento a la derecha
            for (let row = 0; row < 8; row++) {
                matrix.push([]);
                for (let col = 0; col < 8; col++) {
                    const bitIndex = (col + row) % 8;
                    matrix[row].push(byte[bitIndex]);
                }
            }
            
            return matrix;
        }
        
        function generateLeftShiftMatrix(byte) {
            const matrix = [];
            
            // Crear matriz 8x8 con desplazamiento a la izquierda
            for (let row = 0; row < 8; row++) {
                matrix.push([]);
                for (let col = 0; col < 8; col++) {
                    const bitIndex = (col - row + 8) % 8;
                    matrix[row].push(byte[bitIndex]);
                }
            }
            
            return matrix;
        }
        
        function createMatrixSection(title, matrix, originalByte) {
            const container = document.createElement('div');
            container.className = 'matrix-container';
            
            // Título de la matriz
            const titleEl = document.createElement('h3');
            titleEl.className = 'matrix-title';
            titleEl.textContent = title;
            container.appendChild(titleEl);
            
            // Byte original
            const byteInfo = document.createElement('div');
            byteInfo.innerHTML = `<p style="text-align: center; margin-bottom: 15px;">Byte original: ${formatByte(originalByte)} (${parseInt(originalByte, 2)}) → '${String.fromCharCode(parseInt(originalByte, 2))}'</p>`;
            container.appendChild(byteInfo);
            
            // Crear tabla de matriz
            const table = document.createElement('div');
            table.className = 'cubit-matrix';
            
            // Encabezado de columnas
            const emptyHeader = document.createElement('div');
            emptyHeader.className = 'matrix-header';
            emptyHeader.textContent = '';
            table.appendChild(emptyHeader);
            
            for (let i = 0; i < 8; i++) {
                const header = document.createElement('div');
                header.className = 'matrix-header';
                header.textContent = `C${i+1}`;
                table.appendChild(header);
            }
            
            // Filas de la matriz
            for (let row = 0; row < 8; row++) {
                const rowHeader = document.createElement('div');
                rowHeader.className = 'matrix-header';
                rowHeader.textContent = `F${row+1}`;
                table.appendChild(rowHeader);
                
                for (let col = 0; col < 8; col++) {
                    const cell = document.createElement('div');
                    cell.className = `matrix-cell ${matrix[row][col] === '1' ? 'active' : ''}`;
                    cell.textContent = matrix[row][col];
                    table.appendChild(cell);
                }
            }
            
            container.appendChild(table);
            
            // Información de filas y columnas
            const infoPanel = document.createElement('div');
            infoPanel.className = 'info-panel';
            
            const infoTitle = document.createElement('h4');
            infoTitle.className = 'info-title';
            infoTitle.textContent = 'Información de Filas y Columnas:';
            infoPanel.appendChild(infoTitle);
            
            const rowColumnInfo = document.createElement('div');
            rowColumnInfo.className = 'row-column-info';
            
            // Información de filas
            const rowInfo = document.createElement('div');
            rowInfo.className = 'row-info';
            rowInfo.innerHTML = '<h4>Filas (Bytes):</h4>';
            
            for (let row = 0; row < 8; row++) {
                const rowByte = matrix[row].join('');
                const rowValue = parseInt(rowByte, 2);
                const rowItem = document.createElement('div');
                rowItem.className = 'row-item';
                rowItem.innerHTML = `F${row+1}: ${formatByte(rowByte)} = ${rowValue} → '${rowValue > 31 && rowValue < 127 ? String.fromCharCode(rowValue) : '�'}'`;
                rowInfo.appendChild(rowItem);
            }
            
            // Información de columnas
            const columnInfo = document.createElement('div');
            columnInfo.className = 'column-info';
            columnInfo.innerHTML = '<h4>Columnas (Bytes):</h4>';
            
            for (let col = 0; col < 8; col++) {
                let colByte = '';
                for (let row = 0; row < 8; row++) {
                    colByte += matrix[row][col];
                }
                const colValue = parseInt(colByte, 2);
                const colItem = document.createElement('div');
                colItem.className = 'column-item';
                colItem.innerHTML = `C${col+1}: ${formatByte(colByte)} = ${colValue} → '${colValue > 31 && colValue < 127 ? String.fromCharCode(colValue) : '�'}'`;
                columnInfo.appendChild(colItem);
            }
            
            rowColumnInfo.appendChild(rowInfo);
            rowColumnInfo.appendChild(columnInfo);
            infoPanel.appendChild(rowColumnInfo);
            
            container.appendChild(infoPanel);
            
            return container;
        }
        
        function performAdvancedAnalysis(matrixRight, matrixLeft) {
            // Combinar todos los bits de ambas matrices
            let allBits = '';
            
            // Bits de la matriz derecha (8x8 = 64 bits)
            for (let row = 0; row < 8; row++) {
                allBits += matrixRight[row].join('');
            }
            
            // Bits de la matriz izquierda (8x8 = 64 bits)
            for (let row = 0; row < 8; row++) {
                allBits += matrixLeft[row].join('');
            }
            
            // Visualización de bits
            const bitViz = document.getElementById('bitVisualization');
            bitViz.innerHTML = '';
            
            for (let i = 0; i < allBits.length; i++) {
                const bit = document.createElement('div');
                bit.className = `bit-cell ${allBits[i] === '1' ? 'active' : ''}`;
                bit.textContent = allBits[i];
                bitViz.appendChild(bit);
            }
            
            // Generación de clave criptográfica
            document.getElementById('cryptoKey').textContent = allBits;
            
            // Convertir a hexadecimal
            let hexKey = '';
            for (let i = 0; i < allBits.length; i += 4) {
                const nibble = allBits.substring(i, i + 4);
                hexKey += parseInt(nibble, 2).toString(16).toUpperCase();
            }
            document.getElementById('hexKey').textContent = `0x${hexKey}`;
            
            // Convertir a Base64
            let binaryString = '';
            for (let i = 0; i < allBits.length; i += 8) {
                const byte = allBits.substring(i, i + 8);
                binaryString += String.fromCharCode(parseInt(byte, 2));
            }
            document.getElementById('base64Key').textContent = btoa(binaryString);
            
            // Análisis comparativo
            document.getElementById('caesarShift').textContent = parseInt(allBits.substring(0, 5), 2) + 1;
            
            const enigmaPattern = allBits.substring(10, 16);
            document.getElementById('enigmaPattern').textContent = enigmaPattern;
            
            // Simular clave AES derivada
            let aesKey = '';
            for (let i = 0; i < 64; i += 4) {
                aesKey += parseInt(allBits.substring(i, i + 4), 2).toString(16);
            }
            document.getElementById('aesKey').textContent = `${aesKey.substring(0, 4)}...${aesKey.substring(60)}`;
        }
        
        function formatByte(byte) {
            return byte.match(/.{1,1}/g).join(' ');
        }
        
        // Inicializar con un análisis por defecto
        window.onload = () => {
            document.getElementById('convertBtn').click();
        };
    </script>
</body>
</html>
